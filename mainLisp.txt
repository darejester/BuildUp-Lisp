International Allegro CL Free Express Edition
10.1 [32-bit Windows] (Jan 23, 2023 8:51)
Copyright (C) 1985-2023, Franz Inc., Oakland, CA, USA.  All Rights Reserved.

This development copy of Allegro CL is licensed to:
   Allegro CL 10.1 Express user

Loaded options from C:\Users\asus\Documents\allegro\allegro-ide-options.cl.

;; Optimization settings: safety 1, space 1, speed 1, debug 2.
;; For a complete description of all compiler switches given the current optimization
;; settings evaluate (EXPLAIN-COMPILER-SETTINGS).

[changing package from "COMMON-LISP-USER" to "COMMON-GRAPHICS-USER"]
CG-USER(1): 
You closed the last IDE Listener pane, so this new
IDE Listener pane and thread have been created automatically.
CG-USER(1): (defun generate_boneyard ()  
    '(
    (0 0) (0 1) (0 2) (0 3) (0 4) (0 5) (0 6)
          (1 1) (1 2) (1 3) (1 4) (1 5) (1 6)
                (2 2) (2 3) (2 4) (2 5) (2 6)
                      (3 3) (3 4) (3 5) (3 6)
                            (4 4) (4 5) (4 6)
                                  (5 5) (5 6)
                                        (6 6)
    )
)
(generate_boneyard)
;
(defun total (a_domino)  
   (+ (nth 1 a_domino) (nth 2 a_domino))
)
;(total '(2 3))
;
(defun shuffle (a_values)  
    ;(print (total (nth 0 (nth 1 (nth 0 a_values)))))
    ;(print (total (nth 0 (nth 1 (nth 1 a_values)))))
    (cond
        (
            (= (total (nth 0 (nth 1 (nth 0 a_values)))) (total (nth 0 (nth 1 (nth 1 a_values)))))
                (progn
                    (print "shuffle")            
                    (let
                        (
                            (m_values
                                (list
                                    (list
                                        (nth 0 (nth 0 a_values))
                                        (sort (copy-list (nth 1 (nth 0 a_values))) #'(lambda (a b) (< (random 2) 1)))
                                        (nth 2 (nth 0 a_values))
                                        (nth 3 (nth 0 a_values))
                                        (nth 4 (nth 0 a_values))
                                    )
                                    (list
                                        (nth 0 (nth 1 a_values))
                                        (sort (copy-list (nth 1 (nth 1 a_values))) #'(lambda (a b) (< (random 2) 1)))
                                        (nth 2 (nth 1 a_values))
                                        (nth 3 (nth 1 a_values))
                                        (nth 4 (nth 1 a_values))
                                    )
                                    (nth 2 a_values)
                                    
                                )
                            )
                        )
                        (shuffle m_values)
                        ;(print m_values)
                    )   
                )
        )
        (
            (not (= (total (nth 0 (nth 1 (nth 0 a_values)))) (total (nth 0 (nth 1 (nth 1 a_values))))))
                (progn
                    (print "no need to shuffle")
                    a_values
                )
            
        )
        (t (print "ERROR"))
    )
)
;(shuffle)
;
(defun generate_values ()  
    ;put all in let function
    (print "generate values")
    (let(
            (m_values
                (list
                    (list
                        ()
                        ;(generate_boneyard)
                        (mapcar (lambda (sublist) (cons "W" sublist)) (generate_boneyard))
                        ()
                        0
                        0
                    )
                    (list
                        ()
                        ;(generate_boneyard)
                        (mapcar (lambda (sublist) (cons "B" sublist)) (generate_boneyard))
                        ()
                        0
                        0
                    )
                )
            )
        )
        m_values
        ;(print m_values)
    )
)
(generate_values)
;
(defun check_first (a_values)  
    ;put all in let function
    (print "check first")
    ;(print a_values)
    (cond
        (
            (null(nth 2 a_values))
                (progn
                    ;(print "decide who goes first")
                    (cond
                        (
                            (> (total (nth 0 (nth 1 (nth 0 a_values)))) (total (nth 0 (nth 1 (nth 1 a_values)))))
                                (progn
                                    (let
                                        (
                                            (m_values
                                                (list
                                                    (list
                                                        (nth 0 (nth 0 a_values))
                                                        (nth 1 (nth 0 a_values))
                                                        (nth 2 (nth 0 a_values))
                                                        (nth 3 (nth 0 a_values))
                                                        (nth 4 (nth 0 a_values))
                                                    )
                                                    (list
                                                        (nth 0 (nth 1 a_values))
                                                        (nth 1 (nth 1 a_values))
                                                        (nth 2 (nth 1 a_values))
                                                        (nth 3 (nth 1 a_values))
                                                        (nth 4 (nth 1 a_values))
                                                    )
                                                    "Computer"
                                                )
                                            )
                                        )
                                        ;(print m_values)
                                        m_values
                                    )   
                                
                                )
                        )
                        (
                            (< (total (nth 0 (nth 1 (nth 0 a_values)))) (total (nth 0 (nth 1 (nth 1 a_values)))))
                                (progn
                                    (let
                                        (
                                            (m_values
                                                (list
                                                    (list
                                                        (nth 0 (nth 0 a_values))
                                                        (nth 1 (nth 0 a_values))
                                                        (nth 2 (nth 0 a_values))
                                                        (nth 3 (nth 0 a_values))
                                                        (nth 4 (nth 0 a_values))
                                                    )
                                                    (list
                                                        (nth 0 (nth 1 a_values))
                                                        (nth 1 (nth 1 a_values))
                                                        (nth 2 (nth 1 a_values))
                                                        (nth 3 (nth 1 a_values))
                                                        (nth 4 (nth 1 a_values))
                                                    )
                                                    "Human"
                                                )
                                            )
                                        )
                                        ;(print m_values)
                                        m_values
                                    )   
                                
                                )
                        )
                        (t "ERROR")
                    )
                    
                )
            
        )
        (
            (not (null(nth 2 a_values)))
                (
                    (print "no need to decide")
                    a_values
                )
        )
        (t "ERROR")
    )
)
;(check_first)
;
(defun set_stacks (a_values)
    (print "set_stacks")
    (let
        (
            (m_values
                (list
                    (list
                        (subseq (nth 1 (nth 0 a_values))0 6)
                        (subseq (nth 1 (nth 0 a_values))6)
                        (nth 2 (nth 0 a_values))
                        (nth 3 (nth 0 a_values))
                        (nth 4 (nth 0 a_values))
                    )
                    (list
                        (subseq (nth 1 (nth 1 a_values))0 6)
                        (subseq (nth 1 (nth 1 a_values))6)
                        (nth 2 (nth 1 a_values))
                        (nth 3 (nth 1 a_values))
                        (nth 4 (nth 1 a_values))
                    )
                    (nth 2 a_values)
                )
                
            )
        )
        m_values
    )
)
;(set_stacks)
;
(defun draw (a_values)
    ;put all in let function
    (print "draw")
    ;(print a_values)
    (cond 
        (
            (> (length (nth 1(nth 0 a_values))) 6)
                (let
                    (
                        (m_values
                            (list
                                (list
                                    (nth 0 (nth 0 a_values))
                                    (subseq (nth 1 (nth 0 a_values))6)
                                    (subseq (nth 1 (nth 0 a_values))0 6)
                                    (nth 3 (nth 0 a_values))
                                    (nth 4 (nth 0 a_values))
                                )
                                (list
                                    (nth 0 (nth 1 a_values))
                                    (subseq (nth 1 (nth 1 a_values))6)
                                    (subseq (nth 1 (nth 1 a_values))0 6)
                                    (nth 3 (nth 1 a_values))
                                    (nth 4 (nth 1 a_values))
                                )
                                (nth 2 a_values)
                            )
                            
                        )
                    )
                    (print m_values)
                    m_values
                )
        )
        (
            (< (length (nth 1(nth 0 a_values))) 6) 
                (let
                    (
                        (m_values
                            (list
                                (list
                                    (nth 0 (nth 0 a_values))
                                    (subseq (nth 1 (nth 0 a_values))6)
                                    (subseq (nth 1 (nth 0 a_values))0 4)
                                    (nth 3 (nth 0 a_values))
                                    (nth 4 (nth 0 a_values))
                                )
                                (list
                                    (nth 0 (nth 1 a_values))
                                    (subseq (nth 1 (nth 1 a_values))6)
                                    (subseq (nth 1 (nth 1 a_values))0 4)
                                    (nth 3 (nth 1 a_values))
                                    (nth 4 (nth 1 a_values))
                                )
                                (nth 2 a_values)
                            )
                        )
                    )
                    (print m_values)
                    m_values
                )
        )
        (t "ERROR")
    )
)
;(draw)
;
(defun get_player_boneyard(a_values)
    (nth 1 (nth 1 a_values))
)
;(get_player_boneyard)
;
(defun get_player_hand(a_values)
    (nth 2 (nth 1 a_values))
)
;(get_player_hand)
;
(defun get_bot_boneyard(a_values)
    (nth 1 (nth 0 a_values))
)
;(get_bot_boneyard)
;
(defun get_bot_hand(a_values)
    (nth 2 (nth 0 a_values))
)
;(get_bot_hand)
;
(defun get_first_player(a_values)
    (nth 2 a_values)
)
;(get_first_player)
;
(defun get_stack(a_values)
    (append (nth 0(nth 0 a_values)) (nth 0 (nth 1 a_values)))
)
;(get_stack)
;
(defun update_hand(a_hand a_index)
    (append (subseq a_hand 0 a_index)(subseq a_hand (1+ a_index)))
)
;(update_hand)
;
(defun update_stack(a_stack a_hand a_stack_index a_hand_index)
    ;(append (subseq a_stack 0 a_stack_index)(list (nth a_hand_index a_hand))(subseq a_stack a_stack_index))
    (append
        (append 
            (subseq a_stack 0 a_stack_index)(list(nth a_hand_index a_hand))
        )
        (subseq a_stack (1+ a_stack_index))
    )
    
)
;(update_stack)
;
(defun display_board(a_values)
        (print "BOT TOURNAMENT SCORE")
        (print (nth 4 (nth 0 a_values)))
        (print "BOT ROUND SCORE")
        (print (nth 3 (nth 0 a_values)))
        (terpri)
        (print "BOT BONEYARD")
        (print (nth 1 (nth 0 a_values)))
        (print "BOT HAND ")
        (print (nth 2 (nth 0 a_values)))
        (terpri)
        (print "STACKS")
        (print (nth 0 (nth 0 a_values)))
        (print (nth 0 (nth 1 a_values)))
        (terpri)
        (print "PLAYER HAND")
        (print (nth 2 (nth 1 a_values)))
        (print "PLAYER BONEYARD")
        (print (nth 1 (nth 1 a_values)))
        (terpri)
        (print "PLAYER ROUND SCORE")
        (print (nth 3 (nth 1 a_values)))
        (print "PLAYER TOURNAMENT SCORE")
        (print (nth 4 (nth 1 a_values)))
)
;(display_board)
;
(defun player_play(a_values)
    (print "play")
    ;(print a_values)
    (display_board a_values)
    (print "Enter the index of the domino in hand that you want to play")
    (print "Enter the index of the stack that you want to place on")
    (let*
        (
            (m_hand_index
                (read)
            )
            (m_stack_index
                (read)
            )
            (m_updated_stack
                (update_stack (get_stack a_values) (get_player_hand a_values) m_stack_index m_hand_index)
                
            )
            (m_values
                (list
                    (list
                        ;(nth 0 (nth 0 a_values))
                        (subseq m_updated_stack 0 6)
                        (nth 1 (nth 0 a_values))
                        (nth 2 (nth 0 a_values))
                        (nth 3 (nth 0 a_values))
                        (nth 4 (nth 0 a_values))
                    )
                    (list
                        ;(nth 0 (nth 1 a_values))
                        (subseq m_updated_stack 6 12)
                        (nth 1 (nth 1 a_values))
                        ;(cdr(nth 2 (nth 1 a_values)))
                        (update_hand (get_player_hand a_values) m_hand_index)
                        (nth 3 (nth 1 a_values))
                        (nth 4 (nth 1 a_values))
                    )
                    "Computer"
                )
            )
        )
        ;(print (nth m_hand_index (get_player_hand a_values)))
        ;(print (nth m_stack_index (get_stack a_values)))
        ;(print m_updated_stack)
        
        m_values
    )
)
;(player_play)
;
(defun bot_play(a_values)
    (print "play")
    (print a_values)
    (let
        (
            (m_values
                (list
                    (list
                        (nth 0 (nth 0 a_values))
                        (nth 1 (nth 0 a_values))
                        (cdr(nth 2 (nth 0 a_values)))
                        (nth 3 (nth 0 a_values))
                        (nth 4 (nth 0 a_values))
                    )
                    (list
                        (nth 0 (nth 1 a_values))
                        (nth 1 (nth 1 a_values))
                        (nth 2 (nth 1 a_values))
                        (nth 3 (nth 1 a_values))
                        (nth 4 (nth 1 a_values))
                    )
                    "Human"
                )
            )
        )
        
        m_values
    )
)
;(bot_play)
;
(defun turn (a_values)
    (print "turn")
    ;(print (get_player_hand a_values))
    (cond
        ((not(and (= (length (get_player_hand a_values)) 0) (= (length (get_bot_hand a_values)) 0)))
            (progn
                (cond
                    ((string= (get_first_player a_values) "Human")
                        (progn
                            (print "HUMAN")
                            (turn (player_play a_values))
                            
                        )
                    )
                    ((string= (get_first_player a_values) "Computer")
                        (progn
                            (print "COMPUTER")
                            (turn (bot_play a_values))
                        )
                        
                    )
                )
            )
        )
        ((and (= (length (get_player_hand a_values)) 0) (= (length (get_bot_hand a_values)) 0))
            (progn
                ;a_values
                (cond
                    ((not(null (get_player_boneyard a_values)))
                        (turn(draw a_values))
                    )
                    ((null (get_player_boneyard a_values))
                        a_values
                    )
                
                )
                
            )
        )
        (t "ERROR")
    )
    
)
;(turn)
;
(defun read_from_file ()
    (print "serialization file")
    (let(
            (m_values (read))
        )
        m_values
    )
)
;(read_from_file)
;
(defun game (x)
    (cond 
        ((= x 0) 
            (print "start new tournament")
            (turn
                (draw
                    (check_first
                        (set_stacks
                           (shuffle
                                (generate_values)
                            ) 
                        )
                        
                    )
                )
            )
            
        )
        ((= x 1) 
            (print "resume old tournament")
            (read_from_file)
        )
        (t "wrong input. Validate")
    )
)
;(game)
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ask user for input
(format nil "0 : Start New Tournament ~% 1 : Resume Old Tournament")
(game (read))
GENERATE_BONEYARD
CG-USER(2): 
((0 0) (0 1) (0 2) (0 3) (0 4) (0 5) (0 6) (1 1) (1 2) (1 3) ...)
CG-USER(3): 
TOTAL
CG-USER(4): 
SHUFFLE
CG-USER(5): 
GENERATE_VALUES
CG-USER(6): 
"generate values" 
((NIL
  (("W" 0 0) ("W" 0 1) ("W" 0 2) ("W" 0 3) ("W" 0 4) ("W" 0 5) ("W" 0 6) ("W" 1 1)
   ("W" 1 2) ("W" 1 3) ...)
  NIL 0 0)
 (NIL
  (("B" 0 0) ("B" 0 1) ("B" 0 2) ("B" 0 3) ("B" 0 4) ("B" 0 5) ("B" 0 6) ("B" 1 1)
   ("B" 1 2) ("B" 1 3) ...)
  NIL 0 0))
CG-USER(7): 
CHECK_FIRST
CG-USER(8): 
SET_STACKS
CG-USER(9): 
DRAW
CG-USER(10): 
GET_PLAYER_BONEYARD
CG-USER(11): 
GET_PLAYER_HAND
CG-USER(12): 
GET_BOT_BONEYARD
CG-USER(13): 
GET_BOT_HAND
CG-USER(14): 
GET_FIRST_PLAYER
CG-USER(15): 
GET_STACK
CG-USER(16): 
UPDATE_HAND
CG-USER(17): 
UPDATE_STACK
CG-USER(18): 
DISPLAY_BOARD
CG-USER(19): 
PLAYER_PLAY
CG-USER(20): 
BOT_PLAY
CG-USER(21): 
TURN
CG-USER(22): 
READ_FROM_FILE
CG-USER(23): 
GAME
CG-USER(24): 
"0 : Start New Tournament 
 1 : Resume Old Tournament"
CG-USER(25): 0

"start new tournament" 
"generate values" 
"shuffle" 
"no need to shuffle" 
"set_stacks" 
"check first" 
"draw" 
(((("W" 1 1) ("W" 1 2) ("W" 3 3) ("W" 2 6) ("W" 4 6) ("W" 2 5))
  (("W" 0 2) ("W" 0 4) ("W" 0 0) ("W" 0 5) ("W" 1 5) ("W" 3 6) ("W" 2 3) ("W" 4 4)
   ("W" 2 2) ("W" 1 6) ("W" 1 3) ("W" 1 4) ("W" 0 1) ("W" 0 6) ("W" 4 5) ("W" 3 5))
  (("W" 0 3) ("W" 3 4) ("W" 6 6) ("W" 5 5) ("W" 2 4) ("W" 5 6)) 0 0)
 ((("B" 1 5) ("B" 0 5) ("B" 3 4) ("B" 6 6) ("B" 4 4) ("B" 0 1))
  (("B" 3 5) ("B" 4 6) ("B" 1 2) ("B" 3 6) ("B" 0 3) ("B" 1 4) ("B" 4 5) ("B" 1 3)
   ("B" 3 3) ("B" 1 1) ("B" 2 6) ("B" 2 4) ("B" 2 5) ("B" 1 6) ("B" 2 3) ("B" 2 2))
  (("B" 0 6) ("B" 0 0) ("B" 0 4) ("B" 0 2) ("B" 5 6) ("B" 5 5)) 0 0)
 "Human") 
"turn" 
"HUMAN" 
"play" 
"BOT TOURNAMENT SCORE" 
0 
"BOT ROUND SCORE" 
0 

"BOT BONEYARD" 
(("W" 0 2) ("W" 0 4) ("W" 0 0) ("W" 0 5) ("W" 1 5) ("W" 3 6) ("W" 2 3) ("W" 4 4)
 ("W" 2 2) ("W" 1 6) ("W" 1 3) ("W" 1 4) ("W" 0 1) ("W" 0 6) ("W" 4 5) ("W" 3 5)) 
"BOT HAND " 
(("W" 0 3) ("W" 3 4) ("W" 6 6) ("W" 5 5) ("W" 2 4) ("W" 5 6)) 

"STACKS" 
(("W" 1 1) ("W" 1 2) ("W" 3 3) ("W" 2 6) ("W" 4 6) ("W" 2 5)) 
(("B" 1 5) ("B" 0 5) ("B" 3 4) ("B" 6 6) ("B" 4 4) ("B" 0 1)) 

"PLAYER HAND" 
(("B" 0 6) ("B" 0 0) ("B" 0 4) ("B" 0 2) ("B" 5 6) ("B" 5 5)) 
"PLAYER BONEYARD" 
(("B" 3 5) ("B" 4 6) ("B" 1 2) ("B" 3 6) ("B" 0 3) ("B" 1 4) ("B" 4 5) ("B" 1 3)
 ("B" 3 3) ("B" 1 1) ("B" 2 6) ("B" 2 4) ("B" 2 5) ("B" 1 6) ("B" 2 3) ("B" 2 2)) 

"PLAYER ROUND SCORE" 
0 
"PLAYER TOURNAMENT SCORE" 
0 
"Enter the index of the domino in hand that you want to play" 
"Enter the index of the stack that you want to place on" 
